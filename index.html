<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <title>Chicken Runner</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: sans-serif;
            z-index: 1;
        }
    </style>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>
</head>

<body>

    <div id="hud">üí∞: <span id="score">0</span></div>

    <script>
        class Player {
            constructor(scene) {
                this.group = new THREE.Group();

                const body = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4, 16, 16),
                    new THREE.MeshStandardMaterial({ color: 0xffffcc })
                );
                body.position.y = 0.4;
                this.group.add(body);

                const comb = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1),
                    new THREE.MeshStandardMaterial({ color: 0xff0000 })
                );
                comb.position.set(0, 0.8, 0);
                this.group.add(comb);

                const beak = new THREE.Mesh(
                    new THREE.ConeGeometry(0.08, 0.15, 8),
                    new THREE.MeshStandardMaterial({ color: 0xff9900 })
                );
                beak.rotation.x = Math.PI / 2;
                beak.position.set(0, 0.45, 0.38);
                this.group.add(beak);

                const leftWing = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 0.3, 0.2),
                    new THREE.MeshStandardMaterial({ color: 0xffffcc })
                );
                leftWing.position.set(-0.4, 0.4, 0);
                this.group.add(leftWing);

                const rightWing = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 0.3, 0.2),
                    new THREE.MeshStandardMaterial({ color: 0xffffcc })
                );
                rightWing.position.set(0.4, 0.4, 0);
                this.group.add(rightWing);

                const leftLeg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 0.3),
                    new THREE.MeshStandardMaterial({ color: 0xff9900 })
                );
                leftLeg.position.set(-0.15, 0.0, 0);
                this.group.add(leftLeg);

                const rightLeg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 0.3),
                    new THREE.MeshStandardMaterial({ color: 0xff9900 })
                );
                rightLeg.position.set(0.15, 0.0, 0);
                this.group.add(rightLeg);

                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });

                const leftEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.02, 8, 8),
                    eyeMaterial
                );
                leftEye.position.set(-0.12, 0.55, 0.35);
                this.group.add(leftEye);

                const rightEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.02, 8, 8),
                    eyeMaterial
                );
                rightEye.position.set(0.12, 0.55, 0.35);
                this.group.add(rightEye);


                this.group.position.z = 0;
                this.group.position.y = 0.1;
                scene.add(this.group);

                this.posX = 0;
                this.targetX = 0;
                this.speed = 0.2;
                this.score = 0;
                this.isJumping = false;
            }

            moveLeft() {
                this.targetX = Math.max(-1, this.targetX - 1);
            }

            moveRight() {
                this.targetX = Math.min(1, this.targetX + 1);
            }

            jump() {
                if (!this.isJumping) {
                    this.velocityY = 0.2;
                    this.isJumping = true;
                }
            }


            update() {
                this.posX = THREE.MathUtils.lerp(this.posX, this.targetX, this.speed);
                this.group.position.x = this.posX;

                this.group.rotation.y = Math.sin(Date.now() * 0.005) * 0.2;

                if (this.isJumping) {
                    this.group.position.y += this.velocityY;
                    this.velocityY -= 0.01;
                    if (this.group.position.y <= 0.1) {
                        this.group.position.y = 0.1;
                        this.isJumping = false;
                    }
                } else {
                    this.group.position.y = 0.1;
                }
            }
        }

        class Gate {
            constructor(scene, type, value, z) {
                this.group = new THREE.Group();
                this.type = type;
                this.value = value;

                const gateHeight = 2;
                const gateDepth = 0.5;
                const halfWidth = 2;

                // –í–µ—Ä—à–∏–Ω–Ω—ã–π —à–µ–π–¥–µ—Ä (–ø–µ—Ä–µ–¥–∞—ë—Ç –ø–æ–∑–∏—Ü–∏—é)
                const vertexShader = `
            varying vec3 vPosition;
            void main() {
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

                // –§—Ä–∞–≥–º–µ–Ω—Ç–Ω—ã–π —à–µ–π–¥–µ—Ä (—Å–æ–∑–¥–∞—ë—Ç –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç)
                const makeFragmentShader = (baseColorHex) => {
                    const color = new THREE.Color(baseColorHex);
                    return `
                varying vec3 vPosition;
                void main() {
                    float alpha = smoothstep(-0.5, 0.5, vPosition.y); // –æ—Ç 0 (–≤–Ω–∏–∑—É) –¥–æ 1 (–≤–≤–µ—Ä—Ö—É)
                    alpha = 1.0 - alpha; // –∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º: –≤–Ω–∏–∑—É –ø–ª–æ—Ç–Ω–µ–µ
                    gl_FragColor = vec4(${color.r}, ${color.g}, ${color.b}, alpha * 0.8);
                }
            `;
                };

                const leftMaterial = new THREE.ShaderMaterial({
                    vertexShader,
                    fragmentShader: makeFragmentShader(0x4BFFFF),
                    transparent: true
                });
                const leftGeo = new THREE.BoxGeometry(halfWidth, gateHeight, gateDepth);
                const leftMesh = new THREE.Mesh(leftGeo, leftMaterial);
                leftMesh.position.x = -halfWidth / 2;

                const rightMaterial = new THREE.ShaderMaterial({
                    vertexShader,
                    fragmentShader: makeFragmentShader(0xFF4BFF),
                    transparent: true
                });
                const rightGeo = new THREE.BoxGeometry(halfWidth, gateHeight, gateDepth);
                const rightMesh = new THREE.Mesh(rightGeo, rightMaterial);
                rightMesh.position.x = halfWidth / 2;

                this.group.add(leftMesh);
                this.group.add(rightMesh);
                this.group.position.set(0, 0.5, z);

                scene.add(this.group);
            }

            intersects(player) {
                return Math.abs(this.group.position.z - player.group.position.z) < 1
                    && Math.abs(player.posX - 0) < 1;
            }

            removeFromScene(scene) {
                scene.remove(this.group);
            }
        }


        class Coin {
            constructor(scene, z) {
                const geometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 5); // –ü–æ–¥–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–æ –ø–æ–¥ "–º–æ–Ω–µ—Ç—É"
                const material = new THREE.MeshPhongMaterial({ color: 0xffff00 });
                this.cylinder = new THREE.Mesh(geometry, material); // ‚Üê —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ this.cylinder

                this.cylinder.rotation.x = Math.PI / 2; // —á—Ç–æ–±—ã –≤—ã–≥–ª—è–¥–µ–ª–æ –∫–∞–∫ –º–æ–Ω–µ—Ç–∞
                this.cylinder.position.set([-2, 0, 2][Math.floor(Math.random() * 3)], 0.5, z);
                scene.add(this.cylinder);
            }

            intersects(player) {
                return player.group && // –∏–≥—Ä–æ–∫ ‚Äî —ç—Ç–æ —Ç–µ–ø–µ—Ä—å .group
                    Math.abs(this.cylinder.position.z - player.group.position.z) < 1 &&
                    Math.abs(this.cylinder.position.x - player.posX) < 1;
            }
        }


        class Game {
            constructor() {
                this.scene = new THREE.Scene();
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load('./bg.jpg', (texture) => {
                    texture.offset.y = -0.2; // –°–º–µ—â–∞–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É –≤–≤–µ—Ä—Ö (—ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º)
                    this.scene.background = texture;
                });
                this.camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
                this.camera.position.set(0, 3, 3);
                this.camera.lookAt(0, 0, -10);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(innerWidth, innerHeight);
                document.body.appendChild(this.renderer.domElement);

                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(5, 10, 7);
                this.scene.add(light);
                this.scene.add(new THREE.AmbientLight(0x000000));

                const groundGeometry = new THREE.PlaneGeometry(5, 1000);
                const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x555555, side: THREE.DoubleSide });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = Math.PI / 2;
                ground.position.z = -90;
                this.scene.add(ground);

                this.player = new Player(this.scene);
                this.gates = [];
                this.coins = [];

                // –°–æ–∑–¥–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –∏ –º–æ–Ω–µ—Ç
                for (let i = 1; i <= 10; i++) {
                    const z = -10 - i * 20;
                    const type = ["+", "-", "√ó"][i % 3];
                    const val = type == "+" ? 5 : (type == "-" ? 2 : 3);
                    this.gates.push(new Gate(this.scene, type, val, z));
                    this.coins.push(new Coin(this.scene, z + (-2 + Math.random() * 2)));
                }

                this.initControls();
                window.addEventListener('resize', () => this.onResize());
                this.speed = 0.065;
                this.loop();
            }

            initControls() {
                window.addEventListener("keydown", (e) => {
                    if (e.code === "ArrowLeft") this.player.moveLeft();
                    if (e.code === "ArrowRight") this.player.moveRight();
                    if (e.code === "Space" || e.code === "ArrowUp") this.player.jump();
                    if (e.code === 'ArrowDown') {
                        this.player.isJumping = false;
                        // this.speed = Math.max(0.01, this.speed - 0.01); // –£–º–µ–Ω—å—à–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å
                    }
                });

                let touchStartX = 0, touchStartY = 0;
                window.addEventListener("touchstart", (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                });

                window.addEventListener("touchend", (e) => {
                    const dx = e.changedTouches[0].clientX - touchStartX;
                    const dy = e.changedTouches[0].clientY - touchStartY;

                    if (Math.abs(dx) > Math.abs(dy)) {
                        if (dx > 30) this.player.moveRight();
                        else if (dx < -30) this.player.moveLeft();
                    } else {
                        if (dy < -30) this.player.jump();
                    }
                });
            }

            onResize() {
                this.camera.aspect = innerWidth / innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(innerWidth, innerHeight);
            }

            loop() {
                requestAnimationFrame(() => this.loop());

                if (this.paused) return; // Stop updates while paused

                // Move camera and chicken
                this.camera.position.z -= this.speed;
                this.player.group.position.z = this.camera.position.z - 5;
                this.player.update();

                // Move gates and coins
                this.gates.forEach(gate => gate.group.position.z += this.speed);
                this.coins.forEach(coin => coin.cylinder.position.z += this.speed);

                // Check gate collision
                this.gates.forEach((gate, i) => {
                    const dz = Math.abs(gate.group.position.z - this.player.group.position.z);
                    if (dz < 0.5 && !this.paused) {
                        this.pauseAndPrompt(gate);
                        this.gates.splice(i, 1);
                    }
                });

                // Coin check
                this.coins.forEach((coin, i) => {
                    if (
                        Math.abs(coin.cylinder.position.z - this.player.group.position.z) < 0.5 &&
                        Math.abs(coin.cylinder.position.x - this.player.group.position.x) < 0.5
                    ) {
                        this.scene.remove(coin.cylinder);
                        this.coins.splice(i, 1);
                        this.player.score += 1;
                        console.log("Coin collected! Score:", this.player.score);
                    }
                });

                this.renderer.render(this.scene, this.camera);
            }

            pauseAndPrompt(gate) {
                this.paused = true;
                console.log(`Paused at gate: ${gate.type}${gate.value}`);

                // Optionally: show UI (e.g. overlay "Choose Left or Right!")
                // or change color of gate to flash / indicate choice

                setTimeout(() => {
                    // After 2 seconds, resume
                    this.paused = false;

                    // Example: apply gate effect
                    if (gate.type === '+') {
                        this.player.score += gate.value;
                    } else if (gate.type === '-') {
                        this.player.score -= gate.value;
                    } else if (gate.type === '√ó') {
                        this.player.score *= gate.value;
                    }

                    console.log(`Score after gate: ${this.player.score}`);
                }, 2000);
            }

        }

        new Game();
    </script>

</body>

</html>